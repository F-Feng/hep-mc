/**

\defgroup multi_channel_group Multi Channel Integrator

\brief The Multi Channel integration algorithm

In contrast to the VEGAS algorithm, which uses a product of one-dimensional
PDFs, the multi channel integration algorithm uses a sum of user-defined PDFs
\f$ p_j ( \vec{y}) \f$ with automatically adapted weights \f$ \alpha_j \f$ in
the form
\f[
    p ( \vec{y} ) = \sum_{j=1}^M \alpha_j p_j ( \vec{y} ) \text{,} \qquad
    \int \mathrm{d}^d y \; p_j \left( \vec{y} \right) = 1 \text{,} \quad
    \sum_{j=1}^M \alpha_j = 1
\f]
that is used to sample the function. Multi channel integration performs better
compared to VEGAS if the peak structure of the integrand does not factorize. To
avoid explicitly summing over every *channel* \f$ j \f$ for each randomly chosen
point \f$ \vec{x} \in U \equiv [0,1]^d \f$ the MC integrator also samples over
the possible channels. The final formula is
\f[
    I = \int \mathrm{d} i \int_U \mathrm{d}^d x \; J_i ( \vec{x} ) \left.
        \frac{f (\vec{y})}{p (\vec{y})} \right|_{\vec{y} = \vec{y}_i ( \vec{x}
        )} \text{,} \qquad
    i \sim \left\{ \alpha_1, \alpha_2, \ldots, \alpha_M \right\}
\f]
where the integral over the index \f$ i \f$ is understood to be a Monte Carlo
summation in which the index \f$ i \f$ is randomly chosen according to the
specified weights. Since the PDFs \f$ \left\{ p_j \right\}_{j=1}^M \f$ are
user-defined, the user also has to specify the CDFs \f$ \left\{ \vec{y}_j (
\vec{x} ) \right\}_{j=1}^M \f$ for each channel and the jacobian \f$ J_i \f$ for
the selected channel.

The multi channel integration uses the following parameters, where `T` denotes
the numerical type, e.g. `double`:
    - `dimensions` determines the parameter \f$ d \f$,
    - `map_dimensions` determines the size of the vector `coordinates` (see
      below),
    - `channels` determines \f$ M \f$, the number of channels,
    - `densitites` must be the function that calculates *both* the PDFs and the
      CDFs. Its declaration must be as follows:

          T my_density_functions(
              std::size_t channel,
              std::vector<T> const& random_numbers,
              std::vector<T>& coordinates,
              std::vector<T>& densities,
              hep::multi_channel_map action
          );

      - The parameter `channel` gives the randomly selected channel and
        corresponds to the parameter \f$ i \f$ above,
      - `random_numbers` holds the vector \f$ \vec{x} \in U \f$,
      - `coordinates` has the size previously specified by `map_dimensions` and
        must be filled by `my_density_functions` with the components of the
        vector \f$ \vec{y} \in V \f$ using the CDF \f$ \vec{y} = \vec{y}_i  (
        \vec{x} ) \f$ if `action` is `calculate_coordinates`.
	  - The parameter `densities` has the size specified by `channels` and must
		be filled by `my_density_functions` with all densities \f$ \left\{ p_j (
		\vec{y} ) \right\}_{j=1}^M \f$ evaluated at \f$ \vec{y} = \vec{y}_i (
        \vec{x} ) \f$ if the value of `action` is `calcualate_densities`, but it
        also already calculated before.
      - The return value of this function determines the jacobian \f$ J_i (
        \vec{x} ) \f$ of the map \f$ U \to V \f$. If this factor is exactly
        zero, i.e. `T()`, this is taken as a hint to skip the evaluation of
        `function` which would yield zero.
    - `function` must be the integrand function that is integrated over. Its
      declaration must be as described in \ref integrands. The Monte Carlo point
      can be captured e.g. using \ref multi_channel_point or, if `function`
      needs access to data that has been computed already in `densities`, it can
      be captured using \ref multi_channel_point2.

*/
