<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>hep-mc: Multi Channel Integrator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">hep-mc
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="modules.html"><span>Topics</span></a></li>
      <li><a href="namespacehep.html"><span>API&#160;Listing</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multi Channel Integrator</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Multi Channel integration algorithm. </p>
<p>In contrast to the VEGAS algorithm, which uses a product of one-dimensional PDFs, the multi channel integration algorithm uses a sum of user-defined PDFs \( p_j ( \vec{y}) \) with automatically adapted weights \( \alpha_j \) in the form </p><p class="formulaDsp">
\[ p ( \vec{y} ) = \sum_{j=1}^M \alpha_j p_j ( \vec{y} ) \text{,} \qquad \int \mathrm{d}^d y \; p_j \left( \vec{y} \right) = 1 \text{,} \quad \sum_{j=1}^M \alpha_j = 1 \]
</p>
<p> that is used to sample the function. Multi channel integration performs better compared to VEGAS if the peak structure of the integrand does not factorize. To avoid explicitly summing over every <em>channel</em> \( j \) for each randomly chosen point \( \vec{x} \in U \equiv [0,1]^d \) the MC integrator also samples over the possible channels. This leads to the final formula </p><p class="formulaDsp">
\[ I = \int \mathrm{d} i \int_U \mathrm{d}^d x \; J_i ( \vec{x} ) \left. \frac{f (\vec{y})}{p (\vec{y})} \right|_{\vec{y} = \vec{y}_i ( \vec{x} )} \text{,} \qquad i \sim \left\{ \alpha_1, \alpha_2, \ldots, \alpha_M \right\} \]
</p>
<p> where the integral over the index \( i \) is understood to be a Monte Carlo summation in which the index \( i \) is randomly chosen according to the specified weights. Since the PDFs \( \left\{ p_j \right\}_{j=1}^M \) are user-defined, the user also has to specify the CDFs \( \left\{ \vec{y}_j ( \vec{x} ) \right\}_{j=1}^M \) for each channel and the jacobian \( J_i \) for the selected channel.</p>
<p>The multi channel integration uses the following parameters, where <code>T</code> denotes the numerical type, e.g. <code>double</code>:</p><ul>
<li><code>dimensions</code> determines the parameter \( d \),</li>
<li><code>map_dimensions</code> determines the size of the vector <code>coordinates</code> (see below),</li>
<li><code>channels</code> determines \( M \), the number of channels,</li>
<li><code>map</code> must be the function that calculates <em>both</em> the PDFs and the CDFs. Its declaration must be as follows: <pre class="fragment">T map(
    std::size_t channel,
    std::vector&lt;T&gt; const&amp; random_numbers,
    std::vector&lt;T&gt;&amp; coordinates,
    std::vector&lt;T&gt;&amp; densities,
    hep::multi_channel_map action
);
</pre></li>
<li><code>function</code> must be the integrand function that is integrated over. Its declaration must be as described in <a class="el" href="group__integrands.html">Integrand Functions</a>. The Monte Carlo point can be captured e.g. using <a class="el" href="classhep_1_1multi__channel__point.html">multi_channel_point</a> or, if <code>function</code> needs access to data that has been computed already in <code>densities</code>, it can be captured using <a class="el" href="classhep_1_1multi__channel__point2.html">multi_channel_point2</a>. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga74ed8879c3da9b6d85257ce5c317182d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename R  = std::mt19937&gt; </td></tr>
<tr class="memitem:ga74ed8879c3da9b6d85257ce5c317182d"><td class="memTemplItemLeft" align="right" valign="top">std::vector<br class="typebreak" />
&lt; multi_channel_result<br class="typebreak" />
&lt; numeric_type_of&lt; I &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#ga74ed8879c3da9b6d85257ce5c317182d">hep::mpi_multi_channel</a> (MPI_Comm communicator, I &amp;&amp;integrand, std::vector&lt; std::size_t &gt; const &amp;iteration_calls, std::vector&lt; numeric_type_of&lt; I &gt;&gt; const &amp;channel_weights, std::size_t min_calls_per_channel=0, R &amp;&amp;generator=std::mt19937())</td></tr>
<tr class="separator:ga74ed8879c3da9b6d85257ce5c317182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed94fca2e66a440018b187b54919e9c2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename R  = std::mt19937&gt; </td></tr>
<tr class="memitem:gaed94fca2e66a440018b187b54919e9c2"><td class="memTemplItemLeft" align="right" valign="top">std::vector<br class="typebreak" />
&lt; multi_channel_result<br class="typebreak" />
&lt; numeric_type_of&lt; I &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#gaed94fca2e66a440018b187b54919e9c2">hep::mpi_multi_channel</a> (MPI_Comm communicator, I &amp;&amp;integrand, std::vector&lt; std::size_t &gt; const &amp;iteration_calls, std::size_t min_calls_per_channel=0, R &amp;&amp;generator=std::mt19937())</td></tr>
<tr class="separator:gaed94fca2e66a440018b187b54919e9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18278edb48e61e2cfa28fd7e0835cec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac18278edb48e61e2cfa28fd7e0835cec"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#gac18278edb48e61e2cfa28fd7e0835cec">hep::multi_channel_refine_weights</a> (std::vector&lt; T &gt; const &amp;weights, std::vector&lt; T &gt; const &amp;adjustment_data, T minimum_weight)</td></tr>
<tr class="separator:gac18278edb48e61e2cfa28fd7e0835cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7cd33d313859b3e4b46a8647b20e7c8"><td class="memTemplParams" colspan="2">template&lt;typename I , typename R &gt; </td></tr>
<tr class="memitem:gac7cd33d313859b3e4b46a8647b20e7c8"><td class="memTemplItemLeft" align="right" valign="top">multi_channel_result<br class="typebreak" />
&lt; numeric_type_of&lt; I &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#gac7cd33d313859b3e4b46a8647b20e7c8">hep::multi_channel_iteration</a> (I &amp;&amp;integrand, std::size_t calls, std::vector&lt; numeric_type_of&lt; I &gt;&gt; const &amp;channel_weights, R &amp;&amp;generator)</td></tr>
<tr class="separator:gac7cd33d313859b3e4b46a8647b20e7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d8282325fc5e794a2f07a39c7adc2d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename R  = std::mt19937&gt; </td></tr>
<tr class="memitem:ga82d8282325fc5e794a2f07a39c7adc2d"><td class="memTemplItemLeft" align="right" valign="top">std::vector<br class="typebreak" />
&lt; multi_channel_result<br class="typebreak" />
&lt; numeric_type_of&lt; I &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#ga82d8282325fc5e794a2f07a39c7adc2d">hep::multi_channel</a> (I &amp;&amp;integrand, std::vector&lt; std::size_t &gt; const &amp;iteration_calls, std::vector&lt; numeric_type_of&lt; I &gt;&gt; const &amp;channel_weights, std::size_t min_calls_per_channel=0, R &amp;&amp;generator=std::mt19937())</td></tr>
<tr class="separator:ga82d8282325fc5e794a2f07a39c7adc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7175bf9cff4fbb4bd4e2b33becbc5a4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename R  = std::mt19937&gt; </td></tr>
<tr class="memitem:gae7175bf9cff4fbb4bd4e2b33becbc5a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector<br class="typebreak" />
&lt; multi_channel_result<br class="typebreak" />
&lt; numeric_type_of&lt; I &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#gae7175bf9cff4fbb4bd4e2b33becbc5a4">hep::multi_channel</a> (I &amp;&amp;integrand, std::vector&lt; std::size_t &gt; const &amp;iteration_calls, std::size_t min_calls_per_channel=0, R &amp;&amp;generator=std::mt19937())</td></tr>
<tr class="separator:gae7175bf9cff4fbb4bd4e2b33becbc5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga74ed8879c3da9b6d85257ce5c317182d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename R  = std::mt19937&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;multi_channel_result&lt;numeric_type_of&lt;I&gt; &gt; &gt; hep::mpi_multi_channel </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>iteration_calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; numeric_type_of&lt; I &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>channel_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min_calls_per_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em> = <code>std::mt19937()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the MPI-parallelized adaptive multi channel algorithm. See <a class="el" href="group__multi__channel__group.html">Multi Channel Integrator</a> for a detailed description of the parameters. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_channel_example_8cpp-example.html#a3">multi_channel_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaed94fca2e66a440018b187b54919e9c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename R  = std::mt19937&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;multi_channel_result&lt;numeric_type_of&lt;I&gt; &gt; &gt; hep::mpi_multi_channel </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>iteration_calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min_calls_per_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em> = <code>std::mt19937()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the MPI-parallelized adaptive multi channel algorithm. See <a class="el" href="group__multi__channel__group.html">Multi Channel Integrator</a> for a detailed description of the parameters. </p>

</div>
</div>
<a class="anchor" id="ga82d8282325fc5e794a2f07a39c7adc2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename R  = std::mt19937&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;multi_channel_result&lt;numeric_type_of&lt;I&gt; &gt; &gt; hep::multi_channel </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>iteration_calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; numeric_type_of&lt; I &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>channel_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min_calls_per_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em> = <code>std::mt19937()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs <code>iteration_calls.size()</code> multi channel iterations by calling <a class="el" href="group__multi__channel__group.html#gac7cd33d313859b3e4b46a8647b20e7c8">multi_channel_iteration</a> with the specified parameters and refining the weights after each iteration with <a class="el" href="group__multi__channel__group.html#gac18278edb48e61e2cfa28fd7e0835cec">multi_channel_refine_weights</a>. The weights that are used for the first iteration must be given by the parameter <code>channel_weights</code>. See <a class="el" href="group__multi__channel__group.html">Multi Channel Integrator</a> for a description of the remaining parameters. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_channel_example_8cpp-example.html#a2">multi_channel_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae7175bf9cff4fbb4bd4e2b33becbc5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename R  = std::mt19937&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;multi_channel_result&lt;numeric_type_of&lt;I&gt; &gt; &gt; hep::multi_channel </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>iteration_calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min_calls_per_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em> = <code>std::mt19937()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs <code>iteration_calls.size()</code> multi channel iterations by calling <a class="el" href="group__multi__channel__group.html#gac7cd33d313859b3e4b46a8647b20e7c8">multi_channel_iteration</a> with the specified parameters and refining the weights after each iteration with <a class="el" href="group__multi__channel__group.html#gac18278edb48e61e2cfa28fd7e0835cec">multi_channel_refine_weights</a>. The weights used for the first iteration are \( \alpha = 1 / M \) with \( M \) the number of channels. See <a class="el" href="group__multi__channel__group.html">Multi Channel Integrator</a> for a description of the remaining parameters. </p>

</div>
</div>
<a class="anchor" id="gac7cd33d313859b3e4b46a8647b20e7c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">multi_channel_result&lt;numeric_type_of&lt;I&gt; &gt; hep::multi_channel_iteration </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; numeric_type_of&lt; I &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>channel_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs exactly one iteration of the multi channel integration. The parameter <code>channel_weights</code> lets the user specify the weights of each channel. Note that they must add up to one. See <a class="el" href="group__multi__channel__group.html">Multi Channel Integrator</a> for a description of the remaining parameters. </p>

</div>
</div>
<a class="anchor" id="gac18278edb48e61e2cfa28fd7e0835cec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; hep::multi_channel_refine_weights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>adjustment_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>minimum_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses <code>adjustment_data</code> from a previous call of <a class="el" href="group__multi__channel__group.html#gac7cd33d313859b3e4b46a8647b20e7c8">multi_channel_iteration</a> to refine <code>weights</code>. The procedure is the one suggested in Ref. <a class="el" href="citelist.html#CITEREF_WeightOptimization">[2]</a> modified such that the weights are approximately larger then the given <code>minimum_weight</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
