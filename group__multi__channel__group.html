<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hep-mc: Multi Channel Integrator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hep-mc
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multi Channel Integrator</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Multi Channel integration algorithm. </p>
<p>In contrast to the VEGAS algorithm, which uses a product of one-dimensional PDFs, the multi channel integration algorithm uses a sum of \( M \) user-defined PDFs \( p_j ( \vec{y}) \) with automatically adapted weights \( \alpha_j \) in the form </p><p class="formulaDsp">
\[ p ( \vec{y} ) = \sum_{j=1}^M \alpha_j p_j ( \vec{y} ) \text{,} \quad \int \mathrm{d}^d y \; p_j \left( \vec{y} \right) = 1 \text{,} \quad \sum_{j=1}^M \alpha_j = 1 \text{,} \]
</p>
<p> which is used to sample the function. Multi channel integration performs better compared to VEGAS if the peak structure of the integrand does not factorize. To avoid explicitly summing over every channel* \( j \) for each randomly chosen point \( \vec{x} \in U \equiv [0,1]^d \) the MC integrator also samples over the possible channels. This leads to the final formula </p><p class="formulaDsp">
\[ I = \int \mathrm{d} i \int_U \mathrm{d}^d x \; \left. \frac{f (\vec{y})}{p (\vec{y})} \right|_{\vec{y} = \vec{y}_i ( \vec{x} )} \text{,} \qquad i \sim \left\{ \alpha_1, \alpha_2, \ldots, \alpha_M \right\} \]
</p>
<p> where the integral over the index \( i \) is understood to be a Monte Carlo summation in which the index \( i \) is randomly chosen according to the specified weights. Since the PDFs \( \left\{ p_j \right\}_{j=1}^M \) are user-defined, the user also has to specify the CDFs \( \left\{ \vec{y}_j ( \vec{x} ) \right\}_{j=1}^M \) for each channel.</p>
<p>The multi channel integration uses the following parameters, where <code>T</code> denotes the numerical type, e.g. <code>double</code>:</p><ul>
<li><code>dimensions</code> determines the parameter \( d \),</li>
<li><code>map_dimensions</code> determines the size of the vector <code>coordinates</code> (see below),</li>
<li><code>channels</code> determines \( M \), the number of channels,</li>
<li><p class="startli"><code>map</code> must be the function that calculates <em>both</em> the PDFs and the CDFs. Its declaration must be as follows: </p><pre class="fragment">T map(
    std::size_t channel,
    std::vector&lt;T&gt; const&amp; random_numbers,
    std::vector&lt;T&gt;&amp; coordinates,
    std::vector&lt;std::size_t&gt; const&amp; enabled_channels,
    std::vector&lt;T&gt;&amp; densities,
    hep::multi_channel_map action
);
</pre><p class="startli">The parameter <code>action</code> determines what <code>map</code> should do:</p><ul>
<li>If <code>action</code> is <a class="el" href="group__integrands.html#ggadd0057950f5e4375f6fdc21901ea3ca2a66812b0cfcb8711785bd3dec61c1c8cf">hep::multi_channel_map::calculate_coordinates</a>, then the function must use <code>random_numbers</code> to generate a point according to the PDF with the index given by <code>channel</code>. The point itself must be written into <code>coordinates</code>, whose size is already set by the parameter <code>map_dimensions</code> (see above). The return value of <code>map</code> is ignored.</li>
<li>If <code>action</code> is <a class="el" href="group__integrands.html#ggadd0057950f5e4375f6fdc21901ea3ca2ae51b60bddd479cbb9ca91bcf17487871">hep::multi_channel_map::calculate_densities</a>, then the <code>map</code> function must generate the PDFs for the previously generated point, which can be read out of <code>coordinates</code>. The PDFs must be written into <code>densities</code>, whose size is determined by <code>channels</code> (see above). The inverse of the return value of the <code>map</code> function is multiplied with every PDF. The vector <code>enabled_channels</code> stores the indices of all channels whose weights are not zero. If a weight is zero, then the PDF for this channel will be ignored; this can be used to speed up the calculation if there are many disabled channels.</li>
</ul>
<p class="startli">The reason for the having the parameter <code>action</code> is that for some applications the integrand often evaluates to zero. If this happens, the <code>densities</code> are not needed, and then the multi channels integrator skips the possibly costly call to the <code>map</code> function with <code>calculate_densities</code>.</p>
</li>
<li><code>function</code> must be the integrand function that is integrated over. Its declaration must be as described in <a class="el" href="group__integrands.html">Integrand Functions</a>. The Monte Carlo point can be captured e.g. using <a class="el" href="classhep_1_1multi__channel__point.html">multi_channel_point</a> or, if <code>function</code> needs access to data that has been computed already in <code>densities</code>, it can be captured using <a class="el" href="classhep_1_1multi__channel__point2.html">multi_channel_point2</a>. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3cf081911f912c4f1de6fa191ee0aef1"><td class="memTemplParams" colspan="2">template&lt;typename I , typename Checkpoint  = default_multi_channel_chkpt&lt;numeric_type_of&lt;I&gt;&gt;, typename Callback  = mpi_callback&lt;Checkpoint&gt;&gt; </td></tr>
<tr class="memitem:ga3cf081911f912c4f1de6fa191ee0aef1"><td class="memTemplItemLeft" align="right" valign="top">Checkpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#ga3cf081911f912c4f1de6fa191ee0aef1">hep::mpi_multi_channel</a> (MPI_Comm communicator, I &amp;&amp;<a class="el" href="classhep_1_1integrand.html">integrand</a>, std::vector&lt; std::size_t &gt; const &amp;iteration_calls, Checkpoint <a class="el" href="classhep_1_1chkpt.html">chkpt</a>=<a class="el" href="group__checkpoints.html#gae7a758e546d85544ec8db26448f648a5">make_multi_channel_chkpt</a>&lt; <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt; I &gt;&gt;(), Callback <a class="el" href="classhep_1_1callback.html">callback</a>=<a class="el" href="classhep_1_1mpi__callback.html">mpi_callback</a>&lt; Checkpoint &gt;())</td></tr>
<tr class="separator:ga3cf081911f912c4f1de6fa191ee0aef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69450b8a435d6ee7583249cd97d0431"><td class="memTemplParams" colspan="2">template&lt;typename I , typename R &gt; </td></tr>
<tr class="memitem:gad69450b8a435d6ee7583249cd97d0431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhep_1_1multi__channel__result.html">multi_channel_result</a>&lt; <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt; I &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#gad69450b8a435d6ee7583249cd97d0431">hep::multi_channel_iteration</a> (I &amp;&amp;<a class="el" href="classhep_1_1integrand.html">integrand</a>, std::size_t calls, std::vector&lt; <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt; I &gt;&gt; const &amp;channel_weights, R &amp;generator)</td></tr>
<tr class="separator:gad69450b8a435d6ee7583249cd97d0431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8618e6e82ec2d77c0a0b0edff705666"><td class="memTemplParams" colspan="2">template&lt;typename I , typename Checkpoint  = default_multi_channel_chkpt&lt;numeric_type_of&lt;I&gt;&gt;, typename Callback  = callback&lt;Checkpoint&gt;&gt; </td></tr>
<tr class="memitem:gae8618e6e82ec2d77c0a0b0edff705666"><td class="memTemplItemLeft" align="right" valign="top">Checkpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multi__channel__group.html#gae8618e6e82ec2d77c0a0b0edff705666">hep::multi_channel</a> (I &amp;&amp;<a class="el" href="classhep_1_1integrand.html">integrand</a>, std::vector&lt; std::size_t &gt; const &amp;iteration_calls, Checkpoint <a class="el" href="classhep_1_1chkpt.html">chkpt</a>=<a class="el" href="group__checkpoints.html#gae7a758e546d85544ec8db26448f648a5">make_multi_channel_chkpt</a>&lt; <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt; I &gt;&gt;(), Callback <a class="el" href="classhep_1_1callback.html">callback</a>=<a class="el" href="classhep_1_1callback.html">callback</a>&lt; Checkpoint &gt;())</td></tr>
<tr class="separator:gae8618e6e82ec2d77c0a0b0edff705666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3cf081911f912c4f1de6fa191ee0aef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cf081911f912c4f1de6fa191ee0aef1">&#9670;&nbsp;</a></span>mpi_multi_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename Checkpoint  = default_multi_channel_chkpt&lt;numeric_type_of&lt;I&gt;&gt;, typename Callback  = mpi_callback&lt;Checkpoint&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Checkpoint hep::mpi_multi_channel </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>iteration_calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Checkpoint&#160;</td>
          <td class="paramname"><em>chkpt</em> = <code><a class="el" href="group__checkpoints.html#gae7a758e546d85544ec8db26448f648a5">make_multi_channel_chkpt</a>&lt;<a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt;I&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&#160;</td>
          <td class="paramname"><em>callback</em> = <code><a class="el" href="classhep_1_1mpi__callback.html">mpi_callback</a>&lt;Checkpoint&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MPI version of <a class="el" href="group__multi__channel__group.html#gae8618e6e82ec2d77c0a0b0edff705666">multi_channel</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_channel_example_8cpp-example.html#a3">multi_channel_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="gae8618e6e82ec2d77c0a0b0edff705666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8618e6e82ec2d77c0a0b0edff705666">&#9670;&nbsp;</a></span>multi_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename Checkpoint  = default_multi_channel_chkpt&lt;numeric_type_of&lt;I&gt;&gt;, typename Callback  = callback&lt;Checkpoint&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Checkpoint hep::multi_channel </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>iteration_calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Checkpoint&#160;</td>
          <td class="paramname"><em>chkpt</em> = <code><a class="el" href="group__checkpoints.html#gae7a758e546d85544ec8db26448f648a5">make_multi_channel_chkpt</a>&lt;<a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt;I&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&#160;</td>
          <td class="paramname"><em>callback</em> = <code><a class="el" href="classhep_1_1callback.html">callback</a>&lt;Checkpoint&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multi channel integrator. Integrates <code>integrand</code> using <code>iteration_calls.size()</code> iterations, with the number of calls for each iteration given in <code>iteration_calls</code>. The integration starts from the default (empty) checkpoint, unless one is explicitly given in <code>chkpt</code>. After each successful iteration the <code>callback</code> function is invoked.</p>
<dl class="section see"><dt>See also</dt><dd>checkpoints </dd>
<dd>
integrands </dd>
<dd>
callbacks </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_channel_disabled_channels_8cpp-example.html#a2">multi_channel_disabled_channels.cpp</a>, and <a class="el" href="multi_channel_example_8cpp-example.html#a2">multi_channel_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="gad69450b8a435d6ee7583249cd97d0431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69450b8a435d6ee7583249cd97d0431">&#9670;&nbsp;</a></span>multi_channel_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhep_1_1multi__channel__result.html">multi_channel_result</a>&lt;<a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt;I&gt; &gt; hep::multi_channel_iteration </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>calls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">numeric_type_of</a>&lt; I &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>channel_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs exactly one iteration using with multi channel integrator of <code>integrand</code> using exactly <code>calls</code> number of integrand evaluations. The parameter <code>channel_weights</code> must specify the weights of each channel. Note that the weights must be normalized, i.e. their sum must be one. Random numbers are drawn from <code>generator</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
