<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>hep-mc: Integrand Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">hep-mc
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="modules.html"><span>Topics</span></a></li>
      <li><a href="namespacehep.html"><span>API&#160;Listing</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Integrand Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>How integrand functions are written. </p>
<p>Functions that can be integrated by the Monte Carlo algorithms must accept a single parameter of the type <a class="el" href="classhep_1_1mc__point.html">mc_point</a> and return a value of type <code>T</code>. For example, an integrand of the form \( f(x) := x^2 \) implemented with double precision numbers would look like: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> square(<a class="code" href="classhep_1_1mc__point.html">hep::mc_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> x.<a class="code" href="classhep_1_1mc__point.html#a3268be931fcd2035888c95b555636aa2">point</a>[0] * x.<a class="code" href="classhep_1_1mc__point.html#a3268be931fcd2035888c95b555636aa2">point</a>[0];</div>
<div class="line">}</div>
</div><!-- fragment --><p> Some integration algorithms, e.g. <a class="el" href="group__vegas__group.html#gadeec73e19658d11a4fc99776cc92c1f6">vegas</a>, supply additional information that can be accessed by capturing the argument with a different type, e.g. for VEGAS by <a class="el" href="classhep_1_1vegas__point.html">vegas_point</a> : </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> square(<a class="code" href="classhep_1_1vegas__point.html">hep::vegas_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> x.<a class="code" href="classhep_1_1mc__point.html#a3268be931fcd2035888c95b555636aa2">point</a>[0] * x.<a class="code" href="classhep_1_1mc__point.html#a3268be931fcd2035888c95b555636aa2">point</a>[0];</div>
<div class="line">}</div>
</div><!-- fragment --><p>If additional variables in the integrand are necessary, they can be supplied by global variables or using functors: </p><div class="fragment"><div class="line"><span class="keyword">class </span>power</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    power(<span class="keywordtype">double</span> exponent)</div>
<div class="line">        : exponent(exponent)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> operator()(<a class="code" href="classhep_1_1mc__point.html">hep::mc_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::pow(x.<a class="code" href="classhep_1_1mc__point.html#a3268be931fcd2035888c95b555636aa2">point</a>[0], exponent);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">double</span> exponent;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Starting with version 0.5 it is possible to generate differential distributions, which can be generated if a second argument is accepted, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> square_with_distribution(</div>
<div class="line">    <a class="code" href="classhep_1_1mc__point.html">hep::mc_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x,</div>
<div class="line">    <a class="code" href="classhep_1_1projector.html">hep::projector&lt;double&gt;</a>&amp; projector</div>
<div class="line">) {</div>
<div class="line">    <span class="keywordtype">double</span> <span class="keyword">const</span> x = x.<a class="code" href="classhep_1_1mc__point.html#a3268be931fcd2035888c95b555636aa2">point</a>[0];</div>
<div class="line">    <span class="keywordtype">double</span> <span class="keyword">const</span> f = x * x;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// add the the tuple `(x, f)` to the zeroeth distribution</span></div>
<div class="line">    projector.<a class="code" href="classhep_1_1projector.html#aec7cb88f25ea134b1af63e62475f93a6">add</a>(0, x, f);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> f;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Specifying the integrand is not enough for the Monte Carlo integration routines. They also must know how many dimensions, i.e. how many random numbers, the integrand requires and the numeric type with which the operations should be performed. If distribution should be accumulated during the integration the binning (how many bins, upper and lower boundary) must be specified as well. Since this is generic for all algorithms, starting with version 0.5 the complete integrand information is specified by creating an <a class="el" href="classhep_1_1integrand.html">integrand</a>, e.g. for the examples above: </p><div class="fragment"><div class="line"><span class="comment">// the integer specifies the dimension of the integrand `square`, `double`</span></div>
<div class="line"><span class="comment">// specifies the numeric type the integration algorithm should use</span></div>
<div class="line"><span class="keyword">auto</span> square_integrand = hep::make_integrand&lt;double&gt;(square, 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// captures `exponent = 2.0` with an instance of `power` with integrand</span></div>
<div class="line"><span class="comment">// `power::operator()`</span></div>
<div class="line"><span class="keyword">auto</span> power_integrand = hep::make_integrand&lt;double&gt;(power(2.0), 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// the third argument specifies the distribution parameters: the x-axis ranges</span></div>
<div class="line"><span class="comment">// from -10 to 10 and is subdivided into 100 bins</span></div>
<div class="line"><span class="keyword">auto</span> square_distributions = hep::make_integrand&lt;double&gt;(square, 1,</div>
<div class="line">    <a class="code" href="group__distributions.html#gad15207a1e70b88e01af77a6b5ec097ae">hep::make_dist_params</a>(-10.0, +10.0, 200));</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1integrand.html">hep::integrand&lt; T, F, distributions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1mc__point.html">hep::mc_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1multi__channel__integrand.html">hep::multi_channel_integrand&lt; T, F, D, distributions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1multi__channel__point.html">hep::multi_channel_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1multi__channel__point2.html">hep::multi_channel_point2&lt; T, D &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1vegas__point.html">hep::vegas_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab6993610267daf446a6ad7d420802b82"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gab6993610267daf446a6ad7d420802b82"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">hep::numeric_type_of</a> = typename std::remove_reference&lt; I &gt;::type::numeric_type</td></tr>
<tr class="separator:gab6993610267daf446a6ad7d420802b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa04af437998d4319b6e0e268079d0e16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:gaa04af437998d4319b6e0e268079d0e16"><td class="memTemplItemLeft" align="right" valign="top">integrand&lt; T, F, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#gaa04af437998d4319b6e0e268079d0e16">hep::make_integrand</a> (F &amp;&amp;function, std::size_t dimensions)</td></tr>
<tr class="separator:gaa04af437998d4319b6e0e268079d0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858291a90d34ea5e457608b30b54d50a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename... D&gt; </td></tr>
<tr class="memitem:ga858291a90d34ea5e457608b30b54d50a"><td class="memTemplItemLeft" align="right" valign="top">integrand&lt; T, F, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga858291a90d34ea5e457608b30b54d50a">hep::make_integrand</a> (F &amp;&amp;function, std::size_t dimensions, D &amp;&amp;...parameters)</td></tr>
<tr class="separator:ga858291a90d34ea5e457608b30b54d50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f15c4476e45b85fcccc8acecd6c598"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename D &gt; </td></tr>
<tr class="memitem:ga84f15c4476e45b85fcccc8acecd6c598"><td class="memTemplItemLeft" align="right" valign="top">multi_channel_integrand&lt; T, F, <br class="typebreak" />
D, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga84f15c4476e45b85fcccc8acecd6c598">hep::make_multi_channel_integrand</a> (F &amp;&amp;function, std::size_t dimensions, D &amp;&amp;densities, std::size_t map_dimensions, std::size_t channels)</td></tr>
<tr class="separator:ga84f15c4476e45b85fcccc8acecd6c598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a775d1bad801260cd5051d8c473b62e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename D , typename... Ds&gt; </td></tr>
<tr class="memitem:ga4a775d1bad801260cd5051d8c473b62e"><td class="memTemplItemLeft" align="right" valign="top">multi_channel_integrand&lt; T, F, <br class="typebreak" />
D, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga4a775d1bad801260cd5051d8c473b62e">hep::make_multi_channel_integrand</a> (F &amp;&amp;function, std::size_t dimensions, D &amp;&amp;densities, std::size_t map_dimensions, std::size_t channels, Ds &amp;&amp;...parameters)</td></tr>
<tr class="separator:ga4a775d1bad801260cd5051d8c473b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gab6993610267daf446a6ad7d420802b82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">hep::numeric_type_of</a> = typedef typename std::remove_reference&lt;I&gt;::type::numeric_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut for accessing the numeric type of an integrand that is possibly a reference. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa04af437998d4319b6e0e268079d0e16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integrand&lt;T, F, false&gt; hep::make_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PLAIN/VEGAS integrand constructor. This function constructs an <a class="el" href="classhep_1_1integrand.html">integrand</a> using the given <code>function</code> that must accept points from the \( d \)-dimensional hypercube, where \( d \) is given by the parameter <code>dimensions</code>. The type of the point is determined by the integration algorithm later used on the integrand, e.g. for <a class="el" href="group__vegas__group.html#gadeec73e19658d11a4fc99776cc92c1f6">vegas</a> it is <a class="el" href="classhep_1_1vegas__point.html">vegas_point</a>. For this case the integrand would look like: </p><div class="fragment"><div class="line">T <span class="keyword">function</span>(<a class="code" href="classhep_1_1vegas__point.html">hep::vegas_point&lt;T&gt;</a> <span class="keyword">const</span>&amp; x)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// x.point.size() is as large as specified with `dimensions`</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="comment">/* calculate the function value from x.point */</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga858291a90d34ea5e457608b30b54d50a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename... D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integrand&lt;T, F, true&gt; hep::make_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PLAIN/VEGAS distributions constructor. This function constructs an <a class="el" href="classhep_1_1integrand.html">integrand</a> using the given <code>function</code> that must accept points from the \( d \)-dimensional hypercube and a reference to a <a class="el" href="classhep_1_1projector.html">projector</a> that generates the distributions. The dimension \( d \) is given by the parameter <code>dimension</code>, and <code>parameters</code> define the number and parameters of the distribution(s). For the VEGAS algorithm the function would look like: </p><div class="fragment"><div class="line">T <span class="keyword">function</span>(<a class="code" href="classhep_1_1vegas__point.html">hep::vegas_point&lt;T&gt;</a> <span class="keyword">const</span>&amp; x, <a class="code" href="classhep_1_1projector.html">hep::projector&lt;T&gt;</a>&amp; projector)</div>
<div class="line">{</div>
<div class="line">    T <span class="keyword">const</span> x0 = <span class="comment">/* calculate the position of `x` for the distribution 0 */</span>;</div>
<div class="line">    T <span class="keyword">const</span> f = <span class="comment">/* calculate the function value from x.point */</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// add the function value `f` to the zeroeth distribution at `x0`</span></div>
<div class="line">    projector.<a class="code" href="classhep_1_1projector.html#aec7cb88f25ea134b1af63e62475f93a6">add</a>(0, x0, f);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// return the value of the function for the integrator</span></div>
<div class="line">    <span class="keywordflow">return</span> f;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga84f15c4476e45b85fcccc8acecd6c598"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">multi_channel_integrand&lt;T, F, D, false&gt; hep::make_multi_channel_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname"><em>densities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>map_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multi channel integrand constructor. For a description of the parameters see <a class="el" href="group__integrands.html#gaa04af437998d4319b6e0e268079d0e16">make_integrand</a>. In addition, Multi Channel integrators need an additonal function <code>densities</code> that compute the PDFs and the CDFs for a randomly selected channel. This function would look like: </p><div class="fragment"><div class="line">T densities(</div>
<div class="line">    std::size_t channel,</div>
<div class="line">    std::vector&lt;T&gt; <span class="keyword">const</span>&amp; random_numbers,</div>
<div class="line">    std::vector&lt;T&gt;&amp; coordinates,</div>
<div class="line">    std::vector&lt;T&gt;&amp; channel_densities</div>
<div class="line">) {</div>
<div class="line">    <span class="comment">// for the selected `channel`, which is an integer from the half-open</span></div>
<div class="line">    <span class="comment">// interval [0, channels) and the given `random_numbers` with </span></div>
<div class="line">    <span class="comment">// `random_numbers.size() == dimensions` compute the CDFs and store them</span></div>
<div class="line">    <span class="comment">// in `coordinates` which is large as specified with `map_dimensions`.</span></div>
<div class="line">    <span class="comment">// Also compute the PDFs and store them in `channel_densities`</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="comment">/* jacobian */</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4a775d1bad801260cd5051d8c473b62e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename D , typename... Ds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">multi_channel_integrand&lt;T, F, D, true&gt; hep::make_multi_channel_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname"><em>densities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>map_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi channel integrand constructor for distributions. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
