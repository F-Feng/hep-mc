<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hep-mc: Integrand Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hep-mc
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Integrand Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>How integrand functions are written. </p>
<p>Functions that can be integrated by the Monte Carlo algorithms must accept a single parameter of the type <a class="el" href="classhep_1_1mc__point.html">mc_point</a> and return a value of type <code>T</code>. For example, an integrand of the form \( f(x) := x^2 \) implemented with double precision numbers would look like: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> square(<a class="code" href="classhep_1_1mc__point.html">hep::mc_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> x.<a class="code" href="classhep_1_1mc__point.html#ac13ac3873fdc4c74f79c88971a6b2b9d">point</a>[0] * x.<a class="code" href="classhep_1_1mc__point.html#ac13ac3873fdc4c74f79c88971a6b2b9d">point</a>[0];</div><div class="line">}</div></div><!-- fragment --><p> Some integration algorithms, e.g. <a class="el" href="group__vegas__group.html#gac290665acf1c4de2e229c0b88f65701a">vegas</a>, supply additional information that can be accessed by capturing the argument with a different type, e.g. for VEGAS by <a class="el" href="classhep_1_1vegas__point.html">vegas_point</a> : </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> square(<a class="code" href="classhep_1_1vegas__point.html">hep::vegas_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> x.<a class="code" href="classhep_1_1mc__point.html#ac13ac3873fdc4c74f79c88971a6b2b9d">point</a>[0] * x.<a class="code" href="classhep_1_1mc__point.html#ac13ac3873fdc4c74f79c88971a6b2b9d">point</a>[0];</div><div class="line">}</div></div><!-- fragment --><p>If additional variables in the integrand are necessary, they can be supplied by global variables or using functors: </p><div class="fragment"><div class="line"><span class="keyword">class </span>power</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    power(<span class="keywordtype">double</span> exponent)</div><div class="line">        : exponent(exponent)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> operator()(<a class="code" href="classhep_1_1mc__point.html">hep::mc_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::pow(x.<a class="code" href="classhep_1_1mc__point.html#ac13ac3873fdc4c74f79c88971a6b2b9d">point</a>[0], exponent);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">double</span> exponent;</div><div class="line">};</div></div><!-- fragment --><p>Starting with version 0.5 it is possible to generate differential distributions, which can be generated if a second argument is accepted, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> square_with_distribution(</div><div class="line">    <a class="code" href="classhep_1_1mc__point.html">hep::mc_point&lt;double&gt;</a> <span class="keyword">const</span>&amp; x,</div><div class="line">    <a class="code" href="classhep_1_1projector.html">hep::projector&lt;double&gt;</a>&amp; projector</div><div class="line">) {</div><div class="line">    <span class="keywordtype">double</span> <span class="keyword">const</span> x = x.<a class="code" href="classhep_1_1mc__point.html#ac13ac3873fdc4c74f79c88971a6b2b9d">point</a>[0];</div><div class="line">    <span class="keywordtype">double</span> <span class="keyword">const</span> f = x * x;</div><div class="line"></div><div class="line">    <span class="comment">// add the the tuple `(x, f)` to the zeroeth distribution</span></div><div class="line">    projector.<a class="code" href="classhep_1_1projector.html#a0c610f5158ed3f980498b5a9495f8e94">add</a>(0, x, f);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> f;</div><div class="line">}</div></div><!-- fragment --><p>Specifying the integrand is not enough for the Monte Carlo integration routines. They also must know the dimensionsionaly of the integrand, or how many random numbers are needed; furthermore, the numeric type with which the operations should be performed must be specified. If distributions should be accumulated during the integration the binning (how many bins, upper and lower boundaries) must be specified as well. Since this is generic for all algorithms the complete integrand information is specified by creating an <a class="el" href="classhep_1_1integrand.html">integrand</a>, which, for the examples above, would be written as follows: </p><div class="fragment"><div class="line"><span class="comment">// the integer specifies the dimension of the integrand `square`, `double`</span></div><div class="line"><span class="comment">// specifies the numeric type the integration algorithm should use</span></div><div class="line"><span class="keyword">auto</span> square_integrand = hep::make_integrand&lt;double&gt;(square, 1);</div><div class="line"></div><div class="line"><span class="comment">// captures `exponent = 2.0` with an instance of `power` with integrand</span></div><div class="line"><span class="comment">// `power::operator()`</span></div><div class="line"><span class="keyword">auto</span> power_integrand = hep::make_integrand&lt;double&gt;(power(2.0), 1);</div><div class="line"></div><div class="line"><span class="comment">// the third argument specifies the distribution parameters: the x-axis ranges</span></div><div class="line"><span class="comment">// from -10 to 10 and is subdivided into 100 bins</span></div><div class="line"><span class="keyword">auto</span> square_distributions = hep::make_integrand&lt;double&gt;(square, 1,</div><div class="line">    <a class="code" href="group__distributions.html#gaa9dac9fd1ce0a424a049f92107348353">hep::make_dist_params</a>(-10.0, +10.0, 200));</div></div><!-- fragment --><p>An integrand for a multi channel integrator requires even more information because the user must provide PDFs and CDFs. Both must be calculated in a single function that has the following signature: </p><div class="fragment"><div class="line">T map(</div><div class="line">    std::size_t channel,</div><div class="line">    std::vector&lt;T&gt; <span class="keyword">const</span>&amp; random_numbers,</div><div class="line">    std::vector&lt;T&gt;&amp; coordinates,</div><div class="line">    std::vector&lt;std::size_t&gt;&amp; enabled_channels,</div><div class="line">    std::vector&lt;T&gt;&amp; densities,</div><div class="line">    <a class="code" href="group__integrands.html#gadd0057950f5e4375f6fdc21901ea3ca2">hep::multi_channel_map</a> action</div><div class="line">);</div></div><!-- fragment --><p> A <a class="el" href="classhep_1_1multi__channel__integrand.html">multi_channel_integrand</a> is now created as follows: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> mc_integrand = hep::make_multi_channel_integrand&lt;double&gt;(</div><div class="line">    <span class="keyword">function</span>, <span class="comment">// the integrand function that we wish to integrate</span></div><div class="line">    10,       <span class="comment">// the integration is ten dimensional</span></div><div class="line">    map,      <span class="comment">// the map function providing PDFs and CDFs</span></div><div class="line">    20,       <span class="comment">// `map` maps the ten random numbers to twenty in `coordinates`</span></div><div class="line">    200       <span class="comment">// `map` uses two hundred channels</span></div><div class="line">);</div></div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1integrand.html">hep::integrand&lt; T, F, distributions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1mc__point.html">hep::mc_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1multi__channel__integrand.html">hep::multi_channel_integrand&lt; T, F, M, distributions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1multi__channel__point.html">hep::multi_channel_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1multi__channel__point2.html">hep::multi_channel_point2&lt; T, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhep_1_1vegas__point.html">hep::vegas_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga87ca6b96afb5582d22fd87d09a57da75"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , bool distributions&gt; </td></tr>
<tr class="memitem:ga87ca6b96afb5582d22fd87d09a57da75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga87ca6b96afb5582d22fd87d09a57da75">hep::integrand_type</a> = <a class="el" href="classhep_1_1integrand.html">integrand</a>&lt; T, typename std::decay&lt; F &gt;::type, distributions &gt;</td></tr>
<tr class="separator:ga87ca6b96afb5582d22fd87d09a57da75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6993610267daf446a6ad7d420802b82"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gab6993610267daf446a6ad7d420802b82"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">hep::numeric_type_of</a> = typename std::remove_reference&lt; I &gt;::type::numeric_type</td></tr>
<tr class="separator:gab6993610267daf446a6ad7d420802b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d94cad8e866e6f919260f4b93f86efb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename M , bool distributions&gt; </td></tr>
<tr class="memitem:ga2d94cad8e866e6f919260f4b93f86efb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga2d94cad8e866e6f919260f4b93f86efb">hep::multi_channel_integrand_type</a> = <a class="el" href="classhep_1_1multi__channel__integrand.html">multi_channel_integrand</a>&lt; T, typename std::decay&lt; F &gt;::type, typename std::decay&lt; M &gt;::type, distributions &gt;</td></tr>
<tr class="separator:ga2d94cad8e866e6f919260f4b93f86efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadd0057950f5e4375f6fdc21901ea3ca2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__integrands.html#gadd0057950f5e4375f6fdc21901ea3ca2">hep::multi_channel_map</a> { <a class="el" href="group__integrands.html#ggadd0057950f5e4375f6fdc21901ea3ca2a66812b0cfcb8711785bd3dec61c1c8cf">hep::multi_channel_map::calculate_coordinates</a>, 
<a class="el" href="group__integrands.html#ggadd0057950f5e4375f6fdc21901ea3ca2ae51b60bddd479cbb9ca91bcf17487871">hep::multi_channel_map::calculate_densities</a>
 }</td></tr>
<tr class="separator:gadd0057950f5e4375f6fdc21901ea3ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga148947cc9dea1c407f9978a6a5be764f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ga148947cc9dea1c407f9978a6a5be764f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__integrands.html#ga87ca6b96afb5582d22fd87d09a57da75">integrand_type</a>&lt; T, F, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga148947cc9dea1c407f9978a6a5be764f">hep::make_integrand</a> (F &amp;&amp;function, std::size_t dimensions)</td></tr>
<tr class="separator:ga148947cc9dea1c407f9978a6a5be764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55bbd93a1d78a77126ecd5b018c49400"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename... D&gt; </td></tr>
<tr class="memitem:ga55bbd93a1d78a77126ecd5b018c49400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__integrands.html#ga87ca6b96afb5582d22fd87d09a57da75">integrand_type</a>&lt; T, F, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga55bbd93a1d78a77126ecd5b018c49400">hep::make_integrand</a> (F &amp;&amp;function, std::size_t dimensions, D &amp;&amp;... parameters)</td></tr>
<tr class="separator:ga55bbd93a1d78a77126ecd5b018c49400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a159dd6bf73ef664240e7f7888065ab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename M &gt; </td></tr>
<tr class="memitem:ga6a159dd6bf73ef664240e7f7888065ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__integrands.html#ga2d94cad8e866e6f919260f4b93f86efb">multi_channel_integrand_type</a>&lt; T, F, M, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga6a159dd6bf73ef664240e7f7888065ab">hep::make_multi_channel_integrand</a> (F &amp;&amp;function, std::size_t dimensions, M &amp;&amp;map, std::size_t map_dimensions, std::size_t channels)</td></tr>
<tr class="separator:ga6a159dd6bf73ef664240e7f7888065ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f17ff402be0d1c2066e0f2ffb647fbf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename M , typename... Ds&gt; </td></tr>
<tr class="memitem:ga5f17ff402be0d1c2066e0f2ffb647fbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__integrands.html#ga2d94cad8e866e6f919260f4b93f86efb">multi_channel_integrand_type</a>&lt; T, F, M, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integrands.html#ga5f17ff402be0d1c2066e0f2ffb647fbf">hep::make_multi_channel_integrand</a> (F &amp;&amp;function, std::size_t dimensions, M &amp;&amp;map, std::size_t map_dimensions, std::size_t channels, Ds &amp;&amp;... parameters)</td></tr>
<tr class="separator:ga5f17ff402be0d1c2066e0f2ffb647fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga87ca6b96afb5582d22fd87d09a57da75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ca6b96afb5582d22fd87d09a57da75">&#9670;&nbsp;</a></span>integrand_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , bool distributions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__integrands.html#ga87ca6b96afb5582d22fd87d09a57da75">hep::integrand_type</a> = typedef <a class="el" href="classhep_1_1integrand.html">integrand</a>&lt;T, typename std::decay&lt;F&gt;::type, distributions&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template alias for an <a class="el" href="classhep_1_1integrand.html">integrand</a> with its type <code>F</code> decayed with <code>std::decay</code>. </p>

</div>
</div>
<a id="ga2d94cad8e866e6f919260f4b93f86efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d94cad8e866e6f919260f4b93f86efb">&#9670;&nbsp;</a></span>multi_channel_integrand_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename M , bool distributions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__integrands.html#ga2d94cad8e866e6f919260f4b93f86efb">hep::multi_channel_integrand_type</a> = typedef <a class="el" href="classhep_1_1multi__channel__integrand.html">multi_channel_integrand</a>&lt;T, typename std::decay&lt;F&gt;::type, typename std::decay&lt;M&gt;::type, distributions&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template alias for a <a class="el" href="classhep_1_1multi__channel__integrand.html">multi_channel_integrand</a> with its types <code>F</code> and <code>M</code> decayed with <code>std::decay</code>. </p>

</div>
</div>
<a id="gab6993610267daf446a6ad7d420802b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6993610267daf446a6ad7d420802b82">&#9670;&nbsp;</a></span>numeric_type_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__integrands.html#gab6993610267daf446a6ad7d420802b82">hep::numeric_type_of</a> = typedef typename std::remove_reference&lt;I&gt;::type::numeric_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut for accessing the numeric type of an integrand that is possibly a reference. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadd0057950f5e4375f6fdc21901ea3ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd0057950f5e4375f6fdc21901ea3ca2">&#9670;&nbsp;</a></span>multi_channel_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__integrands.html#gadd0057950f5e4375f6fdc21901ea3ca2">hep::multi_channel_map</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration that specifies which parameters of the user specified map should be calculated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd0057950f5e4375f6fdc21901ea3ca2a66812b0cfcb8711785bd3dec61c1c8cf"></a>calculate_coordinates&#160;</td><td class="fielddoc"><p>Signals the map-function that the parameter <code>coordinates</code> should be calculated. The parameter <code>densities</code> can be calculated at time point. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd0057950f5e4375f6fdc21901ea3ca2ae51b60bddd479cbb9ca91bcf17487871"></a>calculate_densities&#160;</td><td class="fielddoc"><p>Signals that the map function is called with the previously calculated <code>coordinates</code> and that the paramter <code>densities</code> now must be calculated. If the integrand does not contribute, i.e. if the user-defined function returned zero, then this step will be skipped because the densities are not needed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga148947cc9dea1c407f9978a6a5be764f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148947cc9dea1c407f9978a6a5be764f">&#9670;&nbsp;</a></span>make_integrand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integrands.html#ga87ca6b96afb5582d22fd87d09a57da75">integrand_type</a>&lt;T, F, false&gt; hep::make_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PLAIN/VEGAS integrand constructor. This function constructs an <a class="el" href="classhep_1_1integrand.html">integrand</a> using the given <code>function</code> that must accept points from the \( d \)-dimensional hypercube, where \( d \) is given by the parameter <code>dimensions</code>. The type of the point is determined by the integration algorithm later used on the integrand, e.g. for <a class="el" href="group__vegas__group.html#gac290665acf1c4de2e229c0b88f65701a">vegas</a> it is <a class="el" href="classhep_1_1vegas__point.html">vegas_point</a>. For this case the integrand would look like: </p><div class="fragment"><div class="line">T <span class="keyword">function</span>(<a class="code" href="classhep_1_1vegas__point.html">hep::vegas_point&lt;T&gt;</a> <span class="keyword">const</span>&amp; x)</div><div class="line">{</div><div class="line">    <span class="comment">// x.point.size() is as large as specified with `dimensions`</span></div><div class="line">    <span class="keywordflow">return</span> <span class="comment">/* calculate the function value from x.point */</span>;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga55bbd93a1d78a77126ecd5b018c49400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55bbd93a1d78a77126ecd5b018c49400">&#9670;&nbsp;</a></span>make_integrand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename... D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integrands.html#ga87ca6b96afb5582d22fd87d09a57da75">integrand_type</a>&lt;T, F, true&gt; hep::make_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PLAIN/VEGAS distributions constructor. This function constructs an <a class="el" href="classhep_1_1integrand.html">integrand</a> using the given <code>function</code> that must accept points from the \( d \)-dimensional hypercube and a reference to a <a class="el" href="classhep_1_1projector.html">projector</a> that generates the distributions. The dimension \( d \) is given by the parameter <code>dimension</code>, and <code>parameters</code> define the number and parameters of the distribution(s). For the VEGAS algorithm the function would look like: </p><div class="fragment"><div class="line">T <span class="keyword">function</span>(<a class="code" href="classhep_1_1vegas__point.html">hep::vegas_point&lt;T&gt;</a> <span class="keyword">const</span>&amp; x, <a class="code" href="classhep_1_1projector.html">hep::projector&lt;T&gt;</a>&amp; projector)</div><div class="line">{</div><div class="line">    T <span class="keyword">const</span> x0 = <span class="comment">/* calculate the position of `x` for the distribution 0 */</span>;</div><div class="line">    T <span class="keyword">const</span> f = <span class="comment">/* calculate the function value from x.point */</span>;</div><div class="line"></div><div class="line">    <span class="comment">// add the function value `f` to the zeroeth distribution at `x0`</span></div><div class="line">    projector.<a class="code" href="classhep_1_1projector.html#a0c610f5158ed3f980498b5a9495f8e94">add</a>(0, x0, f);</div><div class="line"></div><div class="line">    <span class="comment">// return the value of the function for the integrator</span></div><div class="line">    <span class="keywordflow">return</span> f;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6a159dd6bf73ef664240e7f7888065ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a159dd6bf73ef664240e7f7888065ab">&#9670;&nbsp;</a></span>make_multi_channel_integrand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integrands.html#ga2d94cad8e866e6f919260f4b93f86efb">multi_channel_integrand_type</a>&lt;T, F, M, false&gt; hep::make_multi_channel_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>map_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multi channel integrand constructor. For a description of the parameters see <a class="el" href="group__integrands.html#ga148947cc9dea1c407f9978a6a5be764f">make_integrand</a>. In addition, Multi Channel integrators need an additonal function <code>map</code> that computes the PDFs and the CDFs for a randomly selected channel. This function should look like: </p><div class="fragment"><div class="line">T map(</div><div class="line">    std::size_t channel,</div><div class="line">    std::vector&lt;T&gt; <span class="keyword">const</span>&amp; random_numbers,</div><div class="line">    std::vector&lt;T&gt;&amp; coordinates,</div><div class="line">       std::vector&lt;T&gt;&amp; densities,</div><div class="line">    <a class="code" href="group__integrands.html#gadd0057950f5e4375f6fdc21901ea3ca2">hep::multi_channel_map</a> action</div><div class="line">);</div></div><!-- fragment --><p> This function is called by the multi channel integrator, first with the parameter <code>action</code> set to <a class="el" href="group__integrands.html#ggadd0057950f5e4375f6fdc21901ea3ca2a66812b0cfcb8711785bd3dec61c1c8cf">multi_channel_map::calculate_coordinates</a>, which signals that the vector <code>coordinates</code> must be filled using the CDFs. The return value is ignored for this function call. If the integrand returns a non-zero value <code>map</code> is called again with <code>action</code> set to <a class="el" href="group__integrands.html#ggadd0057950f5e4375f6fdc21901ea3ca2ae51b60bddd479cbb9ca91bcf17487871">multi_channel_map::calculate_densities</a>, which means that the vector <code>densities</code> must be populated with all PDFs for the given <code>channel</code> and <code>random_numbers</code>. The return value is the jacobian for the given <code>channel</code>. </p>

</div>
</div>
<a id="ga5f17ff402be0d1c2066e0f2ffb647fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f17ff402be0d1c2066e0f2ffb647fbf">&#9670;&nbsp;</a></span>make_multi_channel_integrand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename M , typename... Ds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integrands.html#ga2d94cad8e866e6f919260f4b93f86efb">multi_channel_integrand_type</a>&lt;T, F, M, true&gt; hep::make_multi_channel_integrand </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>map_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi channel integrand constructor for distributions. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
