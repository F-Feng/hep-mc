<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>hep-mc: Callback Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">hep-mc
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="modules.html"><span>Topics</span></a></li>
      <li><a href="namespacehep.html"><span>API&#160;Listing</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Callback Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Obtaining the results for each iteration as soon as they are available. </p>
<p>VEGAS and the adaptive multi channel integrator are iterative algorithms, i.e. they produce intermediate results after each completed iteration. One usually wants to monitor these, e.g. to ensure results are converging. The callback mechanism lets the user do exactly this, by setting an appropriate callback function, e.g. for VEGAS via <a class="el" href="group__callbacks.html#ga79a82c0b4f488024962cb35e4caea2ff">vegas_callback</a>. This callback function is then called after each completed iteration.</p>
<p>The function must accept a vector of the results, e.g. <a class="el" href="classhep_1_1vegas__result.html">vegas_result</a>, in the case of VEGAS, that will contain the results of every iteration performed so far. Using these results the function must decide if the integrator should proceed with the remaining iterations (in that case the function returns <code>true</code>) or if the integrator should stop and discard the remaining iterations (return <code>false</code>). In the case of MPI-parallized routines the MPI callbacks must also accept the MPI communicator as its first argument.</p>
<p>This library comes with two predefined callback functions for ach integrator,</p>
<ul>
<li>a <code>_default_callback</code> function that is set by default and does nothing and</li>
<li>a <code>_verbose_callback</code> function that prints the result of the recently completed iteration and the cumulative result (using <a class="el" href="group__results.html#gaa780f6f8497c2598902d1e3c59345796">cumulative_result0</a>) of all iterations and the corresponding chi-square per degree of freedom (using <a class="el" href="group__results.html#ga44db028bc67ef05171614a560b0fd400">chi_square_dof0</a>).</li>
</ul>
<p>An example on how to use the return value to stop after a certain precision is reached is shown in <a class="el" href="vegas_stop_after_precision_8cpp-example.html">vegas_stop_after_precision.cpp</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga21c79a6f2c9fd4385a05fb386d1ba717"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21c79a6f2c9fd4385a05fb386d1ba717"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga21c79a6f2c9fd4385a05fb386d1ba717">hep::mpi_multi_channel_callback_type</a> = std::function&lt; bool(MPI_Comm, std::vector&lt; multi_channel_result&lt; T &gt;&gt;)&gt;</td></tr>
<tr class="separator:ga21c79a6f2c9fd4385a05fb386d1ba717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d35524b904724174c8f6aa68f02433c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4d35524b904724174c8f6aa68f02433c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga4d35524b904724174c8f6aa68f02433c">hep::mpi_vegas_callback_type</a> = std::function&lt; bool(MPI_Comm, std::vector&lt; vegas_result&lt; T &gt;&gt;)&gt;</td></tr>
<tr class="separator:ga4d35524b904724174c8f6aa68f02433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c52ccd89ad83c79b89a9a47645578ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c52ccd89ad83c79b89a9a47645578ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga4c52ccd89ad83c79b89a9a47645578ea">hep::multi_channel_callback_type</a> = std::function&lt; bool(std::vector&lt; multi_channel_result&lt; T &gt;&gt;)&gt;</td></tr>
<tr class="separator:ga4c52ccd89ad83c79b89a9a47645578ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c38c3437370a92dcdc1f2788cea20c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf1c38c3437370a92dcdc1f2788cea20c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#gaf1c38c3437370a92dcdc1f2788cea20c">hep::vegas_callback_type</a> = std::function&lt; bool(std::vector&lt; vegas_result&lt; T &gt;&gt;)&gt;</td></tr>
<tr class="separator:gaf1c38c3437370a92dcdc1f2788cea20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga10f9e76f7dd4d3ab9146aa535072c17f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga10f9e76f7dd4d3ab9146aa535072c17f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga10f9e76f7dd4d3ab9146aa535072c17f">hep::mpi_multi_channel_default_callback</a> (MPI_Comm, std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;)</td></tr>
<tr class="separator:ga10f9e76f7dd4d3ab9146aa535072c17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58efbbf32cf33ef996a17080e0bb804"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae58efbbf32cf33ef996a17080e0bb804"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#gae58efbbf32cf33ef996a17080e0bb804">hep::mpi_multi_channel_verbose_callback</a> (MPI_Comm communicator, std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;results)</td></tr>
<tr class="separator:gae58efbbf32cf33ef996a17080e0bb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb5b14dedac3cff9a436a5d8e03c262"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafdb5b14dedac3cff9a436a5d8e03c262"><td class="memTemplItemLeft" align="right" valign="top">mpi_multi_channel_callback_type<br class="typebreak" />
&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#gafdb5b14dedac3cff9a436a5d8e03c262">hep::mpi_multi_channel_callback</a> (mpi_multi_channel_callback_type&lt; T &gt; callback=nullptr)</td></tr>
<tr class="separator:gafdb5b14dedac3cff9a436a5d8e03c262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga225d6f4485f09a059834aec81d2a3d3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga225d6f4485f09a059834aec81d2a3d3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga225d6f4485f09a059834aec81d2a3d3a">hep::mpi_vegas_default_callback</a> (MPI_Comm, std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;)</td></tr>
<tr class="separator:ga225d6f4485f09a059834aec81d2a3d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a83588c26de07916a92af2a0960ec2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a83588c26de07916a92af2a0960ec2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga5a83588c26de07916a92af2a0960ec2c">hep::mpi_vegas_verbose_callback</a> (MPI_Comm communicator, std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;results)</td></tr>
<tr class="separator:ga5a83588c26de07916a92af2a0960ec2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb47eb6529daa5ddf5805612f4045c72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadb47eb6529daa5ddf5805612f4045c72"><td class="memTemplItemLeft" align="right" valign="top">mpi_vegas_callback_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#gadb47eb6529daa5ddf5805612f4045c72">hep::mpi_vegas_callback</a> (mpi_vegas_callback_type&lt; T &gt; callback=nullptr)</td></tr>
<tr class="separator:gadb47eb6529daa5ddf5805612f4045c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0c5d045913730d2434a0ae3b76de7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b0c5d045913730d2434a0ae3b76de7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga7b0c5d045913730d2434a0ae3b76de7c">hep::multi_channel_default_callback</a> (std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;)</td></tr>
<tr class="separator:ga7b0c5d045913730d2434a0ae3b76de7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a4dda7b6a31c7f9a8b35ac78f42921"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1a4dda7b6a31c7f9a8b35ac78f42921"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#gab1a4dda7b6a31c7f9a8b35ac78f42921">hep::multi_channel_verbose_callback</a> (std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;results)</td></tr>
<tr class="separator:gab1a4dda7b6a31c7f9a8b35ac78f42921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d45d9515c0aad6c02c180406125e44b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d45d9515c0aad6c02c180406125e44b"><td class="memTemplItemLeft" align="right" valign="top">multi_channel_callback_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga7d45d9515c0aad6c02c180406125e44b">hep::multi_channel_callback</a> (multi_channel_callback_type&lt; T &gt; callback=nullptr)</td></tr>
<tr class="separator:ga7d45d9515c0aad6c02c180406125e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bf41ad10f8f902300dfe9b6e8d8dc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga30bf41ad10f8f902300dfe9b6e8d8dc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga30bf41ad10f8f902300dfe9b6e8d8dc0">hep::vegas_default_callback</a> (std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;)</td></tr>
<tr class="separator:ga30bf41ad10f8f902300dfe9b6e8d8dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35e15b4e8e6643bdd24dceef39abe48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae35e15b4e8e6643bdd24dceef39abe48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#gae35e15b4e8e6643bdd24dceef39abe48">hep::vegas_verbose_callback</a> (std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;results)</td></tr>
<tr class="separator:gae35e15b4e8e6643bdd24dceef39abe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a82c0b4f488024962cb35e4caea2ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga79a82c0b4f488024962cb35e4caea2ff"><td class="memTemplItemLeft" align="right" valign="top">vegas_callback_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__callbacks.html#ga79a82c0b4f488024962cb35e4caea2ff">hep::vegas_callback</a> (vegas_callback_type&lt; T &gt; callback=nullptr)</td></tr>
<tr class="separator:ga79a82c0b4f488024962cb35e4caea2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga21c79a6f2c9fd4385a05fb386d1ba717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__callbacks.html#ga21c79a6f2c9fd4385a05fb386d1ba717">hep::mpi_multi_channel_callback_type</a> = typedef std::function&lt;bool(MPI_Comm, std::vector&lt;multi_channel_result&lt;T&gt;&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of callback function that can be set by the user with <a class="el" href="group__callbacks.html#gafdb5b14dedac3cff9a436a5d8e03c262">mpi_multi_channel_callback</a>. </p>

</div>
</div>
<a class="anchor" id="ga4d35524b904724174c8f6aa68f02433c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__callbacks.html#ga4d35524b904724174c8f6aa68f02433c">hep::mpi_vegas_callback_type</a> = typedef std::function&lt;bool(MPI_Comm, std::vector&lt;vegas_result&lt;T&gt;&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of callback function that can be set by the user with <a class="el" href="group__callbacks.html#gadb47eb6529daa5ddf5805612f4045c72">mpi_vegas_callback</a>. </p>

</div>
</div>
<a class="anchor" id="ga4c52ccd89ad83c79b89a9a47645578ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__callbacks.html#ga4c52ccd89ad83c79b89a9a47645578ea">hep::multi_channel_callback_type</a> = typedef std::function&lt;bool(std::vector&lt;multi_channel_result&lt;T&gt;&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of callback function that can be set by the user with <a class="el" href="group__callbacks.html#ga7d45d9515c0aad6c02c180406125e44b">multi_channel_callback</a>. </p>

</div>
</div>
<a class="anchor" id="gaf1c38c3437370a92dcdc1f2788cea20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__callbacks.html#gaf1c38c3437370a92dcdc1f2788cea20c">hep::vegas_callback_type</a> = typedef std::function&lt;bool(std::vector&lt;vegas_result&lt;T&gt;&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of callback function that can be set by the user with <a class="el" href="group__callbacks.html#ga79a82c0b4f488024962cb35e4caea2ff">vegas_callback</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafdb5b14dedac3cff9a436a5d8e03c262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpi_multi_channel_callback_type&lt;T&gt; hep::mpi_multi_channel_callback </td>
          <td>(</td>
          <td class="paramtype">mpi_multi_channel_callback_type&lt; T &gt;&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the multi channel <code>callback</code> function and returns it. This function is called after each iteration performed by <a class="el" href="group__vegas__group.html#gaaa3d4ec505e3a7f3f6350c3b87f8fb36">mpi_vegas</a>. The default callback is <a class="el" href="group__callbacks.html#ga10f9e76f7dd4d3ab9146aa535072c17f">mpi_multi_channel_default_callback</a> which does nothing. The callback function can e.g. be set to <a class="el" href="group__callbacks.html#gae58efbbf32cf33ef996a17080e0bb804">mpi_multi_channel_verbose_callback</a> which prints detailed results after each iteration.</p>
<p>If this function is called without any argument, the current callback function is returned. </p>

</div>
</div>
<a class="anchor" id="ga10f9e76f7dd4d3ab9146aa535072c17f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::mpi_multi_channel_default_callback </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default callback function. This function does nothing and always returns <code>true</code>. It is the MPI equivalent of <a class="el" href="group__callbacks.html#ga7b0c5d045913730d2434a0ae3b76de7c">multi_channel_default_callback</a>.</p>
<dl class="section see"><dt>See also</dt><dd>mpi_multi_channel_callback </dd></dl>

</div>
</div>
<a class="anchor" id="gae58efbbf32cf33ef996a17080e0bb804"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::mpi_multi_channel_verbose_callback </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback function that prints a detailed summary about every iteration performed so far. This function always returns <code>true</code>. It is the equivalent of <a class="el" href="group__callbacks.html#gab1a4dda7b6a31c7f9a8b35ac78f42921">multi_channel_verbose_callback</a> and only writes an output if it was called from rank zero to avoid duplicated output.</p>
<dl class="section see"><dt>See also</dt><dd>multi_channel_callback </dd></dl>

</div>
</div>
<a class="anchor" id="gadb47eb6529daa5ddf5805612f4045c72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpi_vegas_callback_type&lt;T&gt; hep::mpi_vegas_callback </td>
          <td>(</td>
          <td class="paramtype">mpi_vegas_callback_type&lt; T &gt;&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the vegas <code>callback</code> function and returns it. This function is called after each iteration performed by <a class="el" href="group__vegas__group.html#gaaa3d4ec505e3a7f3f6350c3b87f8fb36">mpi_vegas</a>. The default callback is <a class="el" href="group__callbacks.html#ga225d6f4485f09a059834aec81d2a3d3a">mpi_vegas_default_callback</a> which does nothing. The callback function can e.g. be set to <a class="el" href="group__callbacks.html#ga5a83588c26de07916a92af2a0960ec2c">mpi_vegas_verbose_callback</a> which prints detailed results after each iteration.</p>
<p>If this function is called without any argument, the current callback function is returned. </p>

</div>
</div>
<a class="anchor" id="ga225d6f4485f09a059834aec81d2a3d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::mpi_vegas_default_callback </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default callback function. This function does nothing and always returns <code>true</code>. It is the MPI equivalent of <a class="el" href="group__callbacks.html#ga30bf41ad10f8f902300dfe9b6e8d8dc0">vegas_default_callback</a>.</p>
<dl class="section see"><dt>See also</dt><dd>mpi_vegas_callback </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a83588c26de07916a92af2a0960ec2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::mpi_vegas_verbose_callback </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback function that prints a detailed summary about every iteration performed so far. This function always returns <code>true</code>. It is the equivalent of <a class="el" href="group__callbacks.html#gae35e15b4e8e6643bdd24dceef39abe48">vegas_verbose_callback</a> and only writes an output if it was called from rank zero to avoid duplicated output.</p>
<dl class="section see"><dt>See also</dt><dd>vegas_callback </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d45d9515c0aad6c02c180406125e44b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">multi_channel_callback_type&lt;T&gt; hep::multi_channel_callback </td>
          <td>(</td>
          <td class="paramtype">multi_channel_callback_type&lt; T &gt;&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the multi channel <code>callback</code> function and returns it. This function is called after each iteration performed by <a class="el" href="group__multi__channel__group.html#ga11e2e9bcca9cf04879f6f59b873fa622">multi_channel</a>. The default callback is <a class="el" href="group__callbacks.html#ga7b0c5d045913730d2434a0ae3b76de7c">multi_channel_default_callback</a>. The function can e.g. be set to <a class="el" href="group__callbacks.html#gab1a4dda7b6a31c7f9a8b35ac78f42921">multi_channel_verbose_callback</a> which prints after each iteration. If the callback function returns <code>false</code> the integration is stopped.</p>
<p>If this function is called without any argument, the previous function is retained. </p>

</div>
</div>
<a class="anchor" id="ga7b0c5d045913730d2434a0ae3b76de7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::multi_channel_default_callback </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default callback function. This function does nothing and always returns <code>true</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__callbacks.html#ga7d45d9515c0aad6c02c180406125e44b">multi_channel_callback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab1a4dda7b6a31c7f9a8b35ac78f42921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::multi_channel_verbose_callback </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; multi_channel_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback function that prints a detailed summary about every iteration performed so far. This function always returns <code>true</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__callbacks.html#ga7d45d9515c0aad6c02c180406125e44b">multi_channel_callback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga79a82c0b4f488024962cb35e4caea2ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vegas_callback_type&lt;T&gt; hep::vegas_callback </td>
          <td>(</td>
          <td class="paramtype">vegas_callback_type&lt; T &gt;&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the vegas <code>callback</code> function and returns it. This function is called after each iteration performed by <a class="el" href="group__vegas__group.html#gaada59d2b99e014be6f362f384da25483">vegas</a>. The default callback is <a class="el" href="group__callbacks.html#ga30bf41ad10f8f902300dfe9b6e8d8dc0">vegas_default_callback</a>. The function can e.g. be set to <a class="el" href="group__callbacks.html#gae35e15b4e8e6643bdd24dceef39abe48">vegas_verbose_callback</a> which prints after each iteration. If the callback function returns <code>false</code> the integration is stopped.</p>
<p>If this function is called without any argument, the previous function is retained. </p>

</div>
</div>
<a class="anchor" id="ga30bf41ad10f8f902300dfe9b6e8d8dc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::vegas_default_callback </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default callback function. This function does nothing and always returns <code>true</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__callbacks.html#ga79a82c0b4f488024962cb35e4caea2ff">vegas_callback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae35e15b4e8e6643bdd24dceef39abe48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hep::vegas_verbose_callback </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; vegas_result&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback function that prints a detailed summary about every iteration performed so far. This function always returns <code>true</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__callbacks.html#ga79a82c0b4f488024962cb35e4caea2ff">vegas_callback</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
